/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */

/* eslint-disable */

var CONTAINER_ID = 'container';

/**
 * Path to prepend to request URLs for the scene .gltf file and the visual logic
 * .js file.
 */
var REL_URL_PREFIX = '/';


/**
 * Load the visual logic .js and/or .xml file or not. The Puzzles Editor is
 * currently not fully supported.
 * See: https://www.soft8soft.com/docs/manual/en/programmers_guide/Integration-with-Reactjs-Vuejs.html#using_the_puzzles_editor
 */
var LOAD_LOGIC_FILES = true;

function createApp(doback = {}) {
    var params = v3d.AppUtils.getPageParams();
    var PUZZLES_DIR = '/puzzles/';
    var logicURL = params.logic ? params.logic : '__LOGIC__visual_logic.js'.replace('__LOGIC__', REL_URL_PREFIX);

    var reg = new RegExp("(^|&)" + "model" + "=([^&]*)(&|$)");
    var r = window.location.search.substr(1).match(reg);
    let modelHibiki = unescape(r[2])
    console.log('modelHibiki:', modelHibiki);
    if (modelHibiki == 'EH001') {

        var sceneURL = params.load ? params.load : '__URL__model/EH001/model.gltf'.replace('__URL__', REL_URL_PREFIX);
    } else if (modelHibiki == "EH002") {

        var sceneURL = params.load ? params.load : '__URL__model/EH002/model.gltf'.replace('__URL__', REL_URL_PREFIX);
    } else if (modelHibiki == 'EH003') {

        var sceneURL = params.load ? params.load : '__URL__model/EH003/model.gltf'.replace('__URL__', REL_URL_PREFIX);
    }




    console.log(sceneURL)
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }
    // some puzzles can benefit from cache
    v3d.Cache.enabled = false;

    return new Promise(function(resolve) {

        if (LOAD_LOGIC_FILES) {
            if (v3d.AppUtils.isXML(logicURL)) {
                var logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
                new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS,
                    function() {
                        var initOptions = v3d.PL ? v3d.PL.execInitPuzzles({
                            container: CONTAINER_ID
                        }).initOptions : { useFullscreen: true };
                        var appInstance = loadScene(sceneURL, initOptions, doback);
                        v3d.PE.viewportUseAppInstance(appInstance);
                        resolve(appInstance);
                    }
                );
            } else if (v3d.AppUtils.isJS(logicURL)) {
                new v3d.PuzzlesLoader().loadLogic(logicURL, function() {
                    var initOptions = v3d.PL ? v3d.PL.execInitPuzzles({
                        container: CONTAINER_ID
                    }).initOptions : { useFullscreen: true };
                    resolve(loadScene(sceneURL, initOptions, doback));
                });
            } else {
                resolve(loadScene(sceneURL, { useFullscreen: true }, doback));
            }
        } else {
            resolve(loadScene(sceneURL, { useFullscreen: true }, doback));
        }

    }).catch(function(err) {
        console.error(err);
    });
}

function loadScene(sceneURL, initOptions, doback) {

    initOptions = initOptions || {};

    var ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    var preloader = initOptions.useCustomPreloader ?
        createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb) :
        new v3d.SimplePreloader({ container: CONTAINER_ID });

    if (v3d.PE) {
        puzzlesEditorPreparePreloader(preloader);
    }

    var app = new v3d.App(CONTAINER_ID, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        app.renderer.setClearColor(0x000000, 0);
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    if (initOptions.useFullscreen) {
        initFullScreen();
    } else {
        var fsButton = document.getElementById('fullscreen_button');
        if (fsButton) fsButton.style.display = 'none';
    }

    sceneURL = initOptions.useCompAssets ? sceneURL + '.xz' : sceneURL;
    app.loadScene(sceneURL, function() {
        app.enableControls();
        app.run();

        if (v3d.PE) v3d.PE.updateAppInstance(app);
        if (v3d.PL) v3d.PL.init(app, initOptions);

        runCode(app, doback);
    }, null, function() {
        console.log('Can\'t load the scene ' + sceneURL);
    });

    return app;
}

function createCustomPreloader(updateCb, finishCb) {
    function CustomPreloader() {
        v3d.Preloader.call(this);
    }

    CustomPreloader.prototype = Object.assign(Object.create(v3d.Preloader.prototype), {
        onUpdate: function(percentage) {
            v3d.Preloader.prototype.onUpdate.call(this, percentage);
            if (updateCb) updateCb(percentage);
        },
        onFinish: function() {
            v3d.Preloader.prototype.onFinish.call(this);
            if (finishCb) finishCb();
        }
    });

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader) {
    // backward compatibility for loading new projects within the old Puzzles Editor
    if (v3d.PE.loadingUpdateCb !== undefined && v3d.PE.loadingFinishCb !== undefined) {
        var _onUpdate = preloader.onUpdate.bind(preloader);
        preloader.onUpdate = function(percentage) {
            _onUpdate(percentage);
            v3d.PE.loadingUpdateCb(percentage);
        }

        var _onFinish = preloader.onFinish.bind(preloader);
        preloader.onFinish = function() {
            _onFinish();
            v3d.PE.loadingFinishCb();
        }
    }
}

function initFullScreen() {

    var fsButton = document.getElementById('fullscreen_button');
    if (!fsButton) return;

    var container = document.getElementById(CONTAINER_ID);

    if (document.fullscreenEnabled ||
        document.webkitFullscreenEnabled ||
        document.mozFullScreenEnabled ||
        document.msFullscreenEnabled)
        fsButton.style.display = 'inline';

    fsButton.addEventListener('click', function(event) {
        event.stopPropagation();
        if (document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement) {
            exitFullscreen();
        } else
            requestFullscreen(container);
    });

    function changeFullscreen() {
        if (document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement) {
            fsButton.classList.remove('fullscreen-open');
            fsButton.classList.add('fullscreen-close');
        } else {
            fsButton.classList.remove('fullscreen-close');
            fsButton.classList.add('fullscreen-open');
        }
    }

    document.addEventListener('webkitfullscreenchange', changeFullscreen);
    document.addEventListener('mozfullscreenchange', changeFullscreen);
    document.addEventListener('msfullscreenchange', changeFullscreen);
    document.addEventListener('fullscreenchange', changeFullscreen);

    function requestFullscreen(elem) {
        if (elem.requestFullscreen)
            elem.requestFullscreen();
        else if (elem.mozRequestFullScreen)
            elem.mozRequestFullScreen();
        else if (elem.webkitRequestFullscreen)
            elem.webkitRequestFullscreen();
        else if (elem.msRequestFullscreen)
            elem.msRequestFullscreen();
    }

    function exitFullscreen() {
        if (document.exitFullscreen)
            document.exitFullscreen();
        else if (document.mozCancelFullScreen)
            document.mozCancelFullScreen();
        else if (document.webkitExitFullscreen)
            document.webkitExitFullscreen();
        else if (document.msExitFullscreen)
            document.msExitFullscreen();
    }
}

function prepareExternalInterface(app) {
    // register functions in the app.ExternalInterface to call them from Puzzles, e.g:
    // app.ExternalInterface.myJSFunction = function() {
    //     console.log('Hello, World!');
    // }

}

function runCode(app, doback) {
    // add your code here, e.g. console.log('Hello, World!');
    // app.showFPS();
    doback()
    pinitFirst(JSON.parse(localStorage.getItem('firstData')))

    if (!PC()) {
        v3d.puzzles.procedures.createJoystickey('static', 'bottomLeft', '100', '#fff');
        //遥感生成后  延迟3秒  注册摇杆事件
        setTimeout(() => {
            v3d.puzzles.procedures.joyEvent(
                function() {},
                function() {},
                function() {}
            )
        }, 2000);
    }





}

function PC() {
    var userAgentInfo = navigator.userAgent;
    var Agents = ["Android", "iPhone",
        "SymbianOS", "Windows Phone",
        "iPad", "iPod"
    ];
    var flag = true;
    for (var v = 0; v < Agents.length; v++) {
        if (userAgentInfo.indexOf(Agents[v]) > 0) {
            flag = false;
            break;
        }
    }
    return flag;
}


function loadAsyncScript(src, callback) {
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    var isLoaded = false;
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", src);
    script.setAttribute("async", true);
    script.setAttribute("defer", true);
    head.appendChild(script);
    console.log(script)
        //fuck ie! duck type  
    if (document.all) {
        script.onreadystatechange = function() {
            var state = this.readyState;
            if (state === 'loaded' || state === 'complete') {
                callback();
            }
        }
    } else {
        //firefox, chrome  
        script.onload = function() {
            callback();
        }
        isLoaded = true;
    }
    if (isLoaded) {
        return true;
    }
}

function successLoaded() {
    console.log('lsjflsjdflk')
}

function pinitFirst(databegot) {
    // while (true) {
    //     if (loadAsyncScript('../.././public/visual_logic.js', successLoaded)) {
    //         setTimeout(() => {
    //             v3d.puzzles.procedures.firstIntoPic(databegot);
    //             console.log('接收到的参数', databegot)
    //         }, 2000);
    //         console.log('加载成功了，马上break循环')
    //         break;
    //     } else {
    //         console.log('加载失败，马上继续加载')
    //         continue;
    //     }
    // }
    setTimeout(() => {
        v3d.puzzles.procedures.firstIntoPic(databegot);
        // console.log('接收到的参数', databegot)
    }, 2000);

}



const screenList = {
        screen_1: {
            position: {
                x: -64.658,
                y: 4.6721,
                z: 20.68963
            },
            rotation: {
                x: 0,
                y: 0,
                z: 90
            }
        }
    }
    /**
     *@param : { modelName } 自定义模型的名字
     *@param : { linkUrl } 需要嵌入的url
     *@param : { modelWidth,modelHeight } 被创建的模型对象的宽高
     *@param : { modelScale } 被创建的模型对象的缩放
     *@param : { screenNum } 设置创建对象在第几个屏幕,对应数据screenList
     */
const setScreen = (modelName, linkUrl, modelWidth, modelHeight, modelScale, screenNum = 'screen_1') => {

    /*   v3d.puzzles.procedures.createHTMLmodel(modelName, linkUrl, modelWidth, modelHeight, modelScale)

    if (screenNum == undefined) return

    let position = screenList[screenNum].position
    let rotation = screenList[screenNum].rotation
 
    v3d.puzzles.procedures.contarlCreateModel('position', position.x, position.y, position.z)
    v3d.puzzles.procedures.contarlCreateModel('rotation', rotation.x, rotation.y, rotation.z) */

}


//物体注册点击事件

function objRegistClickFun(objNmae = 'Screen-1', doBack) {
    console.log('注册')
    v3d.puzzles.procedures.upTip(objNmae, function() {
        //点击回调方法
        console.log('触发Screen-1回调')
        doBack()
    });

}

//修改街机封面
/**
 * 
 * @param {*} nodeName   gameScreen1~11
 * @param {*} materialName  gameScreentexture1~11
 * @param {*} textureURL  填写图片的路径
 */


function replaceScreen(nodeName, materialName, textureURL) {
    v3d.puzzles.procedures.replaceScreen(nodeName, materialName, textureURL);
}

export { createApp, CONTAINER_ID, pinitFirst, setScreen, objRegistClickFun, replaceScreen };